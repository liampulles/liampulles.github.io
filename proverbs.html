---
title: Liam Pulles - Proverbs
description: Proverbs
shareable: true
---
<article>
    <hr>
	<header>
		<h1>Proverbs</h1>
	</header>
	<section>
		<p>Over the years I discover small pieces of cogent advice about programming and being a developer that I find useful.</p> 
		<p>This page tries to collect those thoughts - for my benefit and perhaps others. Email me if you have something good, I'll consider adding it. ;)</p>
	</section>
	
	<section>
		<h2>Code Design</h2>
		
		<section>
			<h3>Design by contract</h3>
			<p><i>Source: <a href="https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/">The Pragmatic Programmer</a></i></p>
<p>Check that the input and output of important functions are sensible. This can be as simple as a few <code>assert</code> statements, e.g.</p>
<script src="https://gist.github.com/liampulles/eacd3ae1d082a34b6fbc5688c27056f7.js"></script>
<p>Do this instead of defensive programming, and apply selectively - put it on your core business logic for specific variables; resources.</p>
<p>By doing this, you'll help minimize unexpected costly errors where bad data somehow gets through to your business logic.</p>
		</section>
		
	</section>
	
	<section>
		<h2>Golang</h2>
		
		<section>
			<h3>Go implementation check</h3>
			<p>Go has <i>structural typing</i>, so a type implements an interface if it defines the same method signatures.</p>
<p>While this can be useful for abstracting external types, it is often nice to be able to check at compile time that a type implements an interface.</p>
<p>A nice pattern I've seen for this is to assign an unnamed global variable of the interface type to an implementation instance, e.g.</p>
<script src="https://gist.github.com/liampulles/ae4ab6989b0f80f09306aa52be9537fe.js"></script>
<p>Here we check that BasicThingy and *StructThingy implement Hashable. If they don't, the compiler will generate a nice error message pointing at the assignment. 
For this reason, it is nice to put this assignment next to the implementation type declaration.</p>
		</section>
		
	</section>
	
	<section>
		<h2>Makefiles</h2>
		
		<section>
			<h3>Makefile tool check and install</h3>
			<p>Often as part of your Makefile, you'll have directives which run dev tools to do things like lint your code, generate mocks, etc. 
What you may not be aware of is that - provided your dev tool can be installed via the shell - you can automate the installation of these
tools when the directives are run for the first time. This makes it trivial for new starters on the repo to get up and going.</p>
<p>Here's an example for a Go tool:</p>
<script src="https://gist.github.com/liampulles/0cbc6042aa79752ca075c25278e552f7.js"></script>
<p>If you run inspect, Make will check if a file at $(GOBIN)/golangci-lint exists. If it does not, the associated directive will be executed,
which then leads to the install directive being executed, and finally whatever shell commands are needed to install the program are run.</p>
<p>Another benefit of this abstraction is that if you update the tool, you can just advise the team to run <code>make install-golangci-lint</code> manually.</p>
		</section>
		
	</section>
	
</article>